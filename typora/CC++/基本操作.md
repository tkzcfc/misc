# C基础

## strcmp和stricmp的区别

```
strcmp比较区分字母大小写 相当是比较的时候纯粹按照ascii码值来比较从头到尾

而stricmp是不区分字母的大小写的。
```



## printf相关

```
%d=int,
%ld=long,
%lld=long long;

在32位编译器上，int=long=32bit；long long=64bit。


```



## ByteToHex  |  HexToByte



```c++

char* ByteToHex(const unsigned char* vByte, const int vLen)
{
    if (!vByte)
    {
        return NULL;
    }

    char* tmp = new char[vLen * 2 + 1]; 

    int tmp2;
    for (int i = 0; i < vLen; i++)
    {
        tmp2 = (int)(vByte[i]) / 16;
        tmp[i * 2] = (char)(tmp2 + ((tmp2 > 9) ? 'A' - 10 : '0'));
        tmp2 = (int)(vByte[i]) % 16;
        tmp[i * 2 + 1] = (char)(tmp2 + ((tmp2 > 9) ? 'A' - 10 : '0'));
    }

    tmp[vLen * 2] = '\0';
    return tmp;
}


unsigned char* HexToByte(const char* szHex)
{
    if (!szHex)
    {
        return NULL;
    }

    int iLen = strlen(szHex);

    if (iLen <= 0 || 0 != iLen % 2)
    {
        return NULL;
    }

    unsigned char* pbBuf = new unsigned char[iLen / 2]; 

    int tmp1, tmp2;
    for (int i = 0; i < iLen / 2; i++)
    {
        tmp1 = (int)szHex[i * 2] - (((int)szHex[i * 2] >= 'A') ? 'A' - 10 : '0');

        if (tmp1 >= 16)
        {
            return NULL;
        }

        tmp2 = (int)szHex[i * 2 + 1] - (((int)szHex[i * 2 + 1] >= 'A') ? 'A' - 10 : '0');

        if (tmp2 >= 16)
        {
            return NULL;
        }

        pbBuf[i] = (tmp1 * 16 + tmp2);
    }

    return pbBuf;
}
```



# 大小端

https://github.com/JacobRBlomquist/Tiny-Endian

https://github.com/ekg/endian



```c++
// from http://stackoverflow.com/a/8979034/238609
inline int IsBigEndian()
{
    union
    {
        unsigned int i;
        char c[sizeof(unsigned int)];
    } u;
    u.i=1;
    return !u.c[0];
}

/* or (pedantic non-UB version) */
inline int IsBigEndian()
{
    int i=1;
    return ! *((char *)&i);
}

// from http://stackoverflow.com/a/4956493/238609
template <typename T>
T swap_endian(T u)
{
    union
    {
        T u;
        unsigned char u8[sizeof(T)];
    } source, dest;

    source.u = u;

    for (size_t k = 0; k < sizeof(T); k++)
        dest.u8[k] = source.u8[sizeof(T) - k - 1];

    return dest.u;
}

template <typename T>
T to_big_endian(T u)
{
    if (IsBigEndian()) {
        return u;
    } else {
        return swap_endian<T>(u);
    }
}

template <typename T>
T to_little_endian(T u)
{
    if (!IsBigEndian()) {
        return u;
    } else {
        return swap_endian<T>(u);
    }
}
```



# git项目

## C&lua

### cmd

```
Bash在cmd.exe中强大的命令行编辑
https://github.com/mridgers/clink
```

### log

```
https://github.com/amrayn/easyloggingpp
```

socks5代理 v2ary安卓客户端

```
https://github.com/eycorsican/kitsunebi-android
```



